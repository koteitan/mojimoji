#!/usr/bin/env node

import { bech32 } from 'bech32';

function toHex(data) {
  return Array.from(data).map(b => b.toString(16).padStart(2, '0')).join('');
}

function fromHex(hex) {
  const bytes = [];
  for (let i = 0; i < hex.length; i += 2) {
    bytes.push(parseInt(hex.substr(i, 2), 16));
  }
  return bytes;
}

function toString(data) {
  return new TextDecoder().decode(new Uint8Array(data));
}

function fromString(str) {
  return Array.from(new TextEncoder().encode(str));
}

function decodeSimple(data) {
  return { hex: toHex(data) };
}

function decodeTLV(data, schema) {
  const result = {};
  const relays = [];

  let i = 0;
  while (i < data.length) {
    const type = data[i];
    const length = data[i + 1];
    if (length === undefined) break;
    const value = data.slice(i + 2, i + 2 + length);

    const field = schema[type];
    if (field) {
      if (field.type === 'hex') {
        result[field.name] = toHex(value);
      } else if (field.type === 'string') {
        result[field.name] = toString(value);
      } else if (field.type === 'int') {
        result[field.name] = value.reduce((acc, b, idx) => acc + (b << (8 * (value.length - 1 - idx))), 0);
      } else if (field.type === 'relay') {
        relays.push(toString(value));
      }
    }

    i += 2 + length;
  }

  if (relays.length > 0) {
    result.relays = relays;
  }

  return result;
}

function decode(input) {
  const trimmed = input.trim().toLowerCase();

  const decoded = bech32.decode(trimmed, 5000);
  const prefix = decoded.prefix;
  const data = bech32.fromWords(decoded.words);

  let result = { type: prefix };

  switch (prefix) {
    case 'npub':
    case 'nsec':
    case 'note':
      Object.assign(result, decodeSimple(data));
      break;

    case 'nprofile':
      Object.assign(result, decodeTLV(data, {
        0: { name: 'pubkey', type: 'hex' },
        1: { name: 'relay', type: 'relay' },
      }));
      break;

    case 'nevent':
      Object.assign(result, decodeTLV(data, {
        0: { name: 'eventId', type: 'hex' },
        1: { name: 'relay', type: 'relay' },
        2: { name: 'author', type: 'hex' },
        3: { name: 'kind', type: 'int' },
      }));
      break;

    case 'naddr':
      Object.assign(result, decodeTLV(data, {
        0: { name: 'pubkey', type: 'hex' },
        1: { name: 'relay', type: 'relay' },
        2: { name: 'dTag', type: 'string' },
        3: { name: 'kind', type: 'int' },
      }));
      break;

    case 'nrelay':
      Object.assign(result, decodeTLV(data, {
        0: { name: 'url', type: 'string' },
      }));
      break;

    default:
      result.raw = toHex(data);
      break;
  }

  return result;
}

function encodeTLV(type, tlvEntries) {
  const data = [];
  for (const entry of tlvEntries) {
    data.push(entry.type);
    data.push(entry.value.length);
    data.push(...entry.value);
  }
  const words = bech32.toWords(new Uint8Array(data));
  return bech32.encode(type, words, 5000);
}

function encodeSimple(type, hex) {
  const data = fromHex(hex);
  const words = bech32.toWords(new Uint8Array(data));
  return bech32.encode(type, words, 5000);
}

function intToBytes(n, len = 4) {
  const bytes = [];
  for (let i = len - 1; i >= 0; i--) {
    bytes.push((n >> (8 * i)) & 0xff);
  }
  return bytes;
}

function encode(json) {
  const { type, hex, pubkey, eventId, author, kind, dTag, relays, url } = json;

  switch (type) {
    case 'npub':
    case 'nsec':
    case 'note':
      return encodeSimple(type, hex);

    case 'nprofile': {
      const tlv = [];
      if (pubkey) tlv.push({ type: 0, value: fromHex(pubkey) });
      if (relays) {
        for (const r of relays) {
          tlv.push({ type: 1, value: fromString(r) });
        }
      }
      return encodeTLV('nprofile', tlv);
    }

    case 'nevent': {
      const tlv = [];
      if (eventId) tlv.push({ type: 0, value: fromHex(eventId) });
      if (relays) {
        for (const r of relays) {
          tlv.push({ type: 1, value: fromString(r) });
        }
      }
      if (author) tlv.push({ type: 2, value: fromHex(author) });
      if (kind !== undefined) tlv.push({ type: 3, value: intToBytes(kind) });
      return encodeTLV('nevent', tlv);
    }

    case 'naddr': {
      const tlv = [];
      if (pubkey) tlv.push({ type: 0, value: fromHex(pubkey) });
      if (relays) {
        for (const r of relays) {
          tlv.push({ type: 1, value: fromString(r) });
        }
      }
      if (dTag) tlv.push({ type: 2, value: fromString(dTag) });
      if (kind !== undefined) tlv.push({ type: 3, value: intToBytes(kind) });
      return encodeTLV('naddr', tlv);
    }

    case 'nrelay': {
      const tlv = [];
      if (url) tlv.push({ type: 0, value: fromString(url) });
      return encodeTLV('nrelay', tlv);
    }

    default:
      throw new Error(`Unknown type: ${type}`);
  }
}

// Convert 5-bit words to bytes without strict padding check
function fromWordsLoose(words) {
  let value = 0;
  let bits = 0;
  const result = [];

  for (const word of words) {
    value = (value << 5) | word;
    bits += 5;

    while (bits >= 8) {
      bits -= 8;
      result.push((value >> bits) & 0xff);
    }
  }

  // Ignore remaining bits (loose mode)
  return result;
}

// Manually decode bech32 without checksum validation (for -f option)
function decodeNoChecksum(input) {
  const CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
  const trimmed = input.trim().toLowerCase();

  // Find separator (last '1' in the string)
  const sepIndex = trimmed.lastIndexOf('1');
  if (sepIndex < 1) {
    throw new Error('Invalid bech32: no separator found');
  }

  const prefix = trimmed.slice(0, sepIndex);
  const datapart = trimmed.slice(sepIndex + 1);

  // Decode data part to 5-bit words
  const words = [];
  for (const c of datapart) {
    const idx = CHARSET.indexOf(c);
    if (idx === -1) {
      throw new Error(`Invalid character: ${c}`);
    }
    words.push(idx);
  }

  // Remove last 6 characters (checksum)
  const dataWords = words.slice(0, -6);

  // Convert 5-bit words to bytes (loose mode - ignore padding errors)
  const data = fromWordsLoose(dataWords);

  return { prefix, data };
}

// Read stdin
async function readStdin() {
  const chunks = [];
  for await (const chunk of process.stdin) {
    chunks.push(chunk);
  }
  return Buffer.concat(chunks).toString('utf-8');
}

// Parse arguments
let forceMode = false;
let inputArg = null;

for (let i = 2; i < process.argv.length; i++) {
  const arg = process.argv[i];
  if (arg === '-f' || arg === '--force') {
    forceMode = true;
  } else if (!inputArg) {
    inputArg = arg;
  }
}

// Main
if (inputArg) {
  // Decode mode: argument is bech32 string
  try {
    console.log(JSON.stringify(decode(inputArg), null, 2));
  } catch (err) {
    if (forceMode) {
      // Try to decode without checksum validation
      try {
        console.error(`Warning: ${err.message} (forcing decode)`);
        const { prefix, data } = decodeNoChecksum(inputArg);
        let result = { type: prefix, checksumInvalid: true };

        switch (prefix) {
          case 'npub':
          case 'nsec':
          case 'note':
            Object.assign(result, decodeSimple(data));
            break;
          case 'nprofile':
            Object.assign(result, decodeTLV(data, {
              0: { name: 'pubkey', type: 'hex' },
              1: { name: 'relay', type: 'relay' },
            }));
            break;
          case 'nevent':
            Object.assign(result, decodeTLV(data, {
              0: { name: 'eventId', type: 'hex' },
              1: { name: 'relay', type: 'relay' },
              2: { name: 'author', type: 'hex' },
              3: { name: 'kind', type: 'int' },
            }));
            break;
          case 'naddr':
            Object.assign(result, decodeTLV(data, {
              0: { name: 'pubkey', type: 'hex' },
              1: { name: 'relay', type: 'relay' },
              2: { name: 'dTag', type: 'string' },
              3: { name: 'kind', type: 'int' },
            }));
            break;
          case 'nrelay':
            Object.assign(result, decodeTLV(data, {
              0: { name: 'url', type: 'string' },
            }));
            break;
          default:
            result.raw = toHex(data);
            break;
        }

        console.log(JSON.stringify(result, null, 2));
      } catch (forceErr) {
        console.error(`Error: ${forceErr.message}`);
        process.exit(1);
      }
    } else {
      console.error(`Error: ${err.message}`);
      process.exit(1);
    }
  }
} else {
  // Encode mode: read JSON from stdin
  readStdin().then(input => {
    try {
      const json = JSON.parse(input.trim());
      console.log(encode(json));
    } catch (err) {
      console.error(`Error: ${err.message}`);
      process.exit(1);
    }
  }).catch(err => {
    console.error('Usage:');
    console.error('  Decode: bech32 [-f] <npub|nsec|note|nprofile|nevent|naddr|nrelay>');
    console.error('  Encode: echo \'{"type":"npub","hex":"..."}\' | bech32');
    console.error('');
    console.error('Options:');
    console.error('  -f, --force  Decode even if checksum is invalid');
    process.exit(1);
  });
}
